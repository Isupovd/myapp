<h1 align="center">Подсистема ввода-вывода и управления внешними устройствами</h1>
<table align="center" width="85%" border="0" bgcolor="#2F4F4F">
	<tr>
		<td>
			<p>Одной из главных функций ОС является управление всеми устройствами ввода-вывода компьютера. ОС должна передавать устройствам команды, перехватывать прерывания и обрабатывать ошибки; она также должна обеспечивать интерфейс между устройствами и остальной частью системы. </p>
			<p><b>Физическая организация устройств ввода-вывода</b></p>
			<p>Устройства ввода-вывода делятся на два типа: блочные устройства и символьные устройства. </p>
			<p>Блочные устройства хранят информацию в блоках фиксированного размера, каждый из которых имеет свой собственный адрес. Важное свойство блочного устройства состоит в том, что каждый его блок может быть прочитан независимо от других устройств. Самое распространенное блочное устройство - диск. </p>
			<p>Символьные устройства принимают или предоставляют поток символов без какой-либо блочной структуры. Они не адресуемы и не позволяют производить операцию поиска, они генерируют или потребляют последовательность байтов. Примерами являются терминалы,  сетевые адаптеры. Однако некоторые внешние устройства не относятся ни к одному классу, например, таймер, который, с одной стороны, не адресуем, а с другой стороны, не порождает потока байтов. Это устройство только выдает сигнал прерывания в некоторые моменты времени.</p>
			<p>Внешнее устройство обычно состоит из механического и электронного компонентов. Электронный компонент называется контроллером устройства или адаптером. Механический компонент представляет собственно устройство. Плата контроллера обычно снабжена разъемом, к которому может быть подключен кабель, ведущий к самому устройству. Некоторые контроллеры могут управлять несколькими устройствами. Если интерфейс между контроллером и устройством стандартизован, то независимые производители могут выпускать совместимые как контроллеры, так и устройства.</p>
			<p>Операционная система обычно имеет дело не с устройством, а с контроллером. Контроллер, как правило, выполняет простые функции, например, преобразует поток бит в блоки, состоящие из байтов, и осуществляет контроль и исправление ошибок. Каждый контроллер имеет несколько регистров, которые используются для взаимодействия с центральным процессором. При помощи записи в эти регистры ОС велит устройству предоставить данные, принять данные, включиться или выключиться и т.п. Читая из этих регистров, ОС может узнать состояние устройства, например, готово ли оно к принятию новой команды и т.д. Помимо управляющих регистров, у многих устройств есть буфер данных, из которого ОС может читать данные, а также писать данные в него.</p>
			<ul>Существует три способа реализации доступа к управляющим регистрам и буферам данных устройств ввода-вывода:
				<li>Первый способ заключается в том, что каждому управляющему регистру назначается номер порта ввода-вывода, 8- или 16-разрядное целое число. Кроме того, вводятся специальные команды процессора IN reg, port для чтения и OUT port, reg для записи в управляющие регистры. </li>
				<li>Второй способ состоит в отображении всех управляющих регистров периферийных устройств на адресное пространство памяти. Каждому управляющему регистру назначается свой уникальный адрес в памяти. </li>
				<li>Также существуют различные гибридные схемы, когда буферы данных тоже отображаются на адресное пространство и выделяются отдельные порты ввода-вывода. Эта схема широко применяется в компьютерах на базе процессоров Pentium, в которых помимо портов ввода-вывода с номерами от 0 до 64К, адресное пространство ОП от 640К до 1 М зарезервировано под буферы данных устройств ввода-вывода.</li>
			</ul>
			<p>ОС выполняет ввод-вывод, записывая команды в регистры контроллера. Например, контроллер гибкого диска IBM PC принимает 15 команд, таких как READ, WRITE, SEEK, FORMAT и т.д. Когда команда принята, процессор оставляет контроллер и занимается другой работой. При завершении команды контроллер организует прерывание для того, чтобы передать управление процессором операционной системе, которая должна проверить результаты операции. Процессор получает результаты и статус устройства, читая информацию из регистров контроллера. Прерывания очень важны в работе ОС, поэтому рассмотрим это понятие более подробно. </p>
			<p>1. Драйвер передает команду контроллеру, записывая информацию в регистры устройства. Затем контроллер запускает устройство. </p>
			<p>2. Когда устройство ввода-вывода заканчивает свою работу, оно инициирует прерывание. Для этого устройство посылает сигнал, контроллеру прерываний, используя определенные провода шины.</p>
			<p>3. Если контроллер прерываний готов к приему прерывания, то он выставляет на адресную шину номер устройства, требующего к себе внимания, и устанавливает сигнал прерывания на соответствующий контакт процессора. Этот сигнал заставляет процессор приостановить текущую работу и начать выполнять обработку прерывания. </p>
			<p>4. Содержимое счетчика команд и слово состояния процессора помещаются в стек, а номер, выставленный на адресную шину, используется в качестве индекса в таблице, называемой вектором прерываний, из которой извлекается новое значение счетчика команд. Новый счетчик команд указывает на начало соответствующей процедуры обработки прерывания. 
Вскоре после начала своей работы процедура обработки прерываний подтверждает полученное прерывание, записывая определенное значение в порт контроллера прерываний. Это подтверждение разрешает контроллеру издавать новые прерывания. После того как обработка прерывания целиком завершена, управление возвращается к работающей до этого программе пользователя, к той команде, выполнение которой еще не было закончено.</p>
<br>
<p><b>Организация программного обеспечения ввода-вывода</b></p>
<p>Основная идея организации программного обеспечения ввода-вывода состоит в разбиении его на несколько уровней, причем нижние уровни обеспечивают экранирование особенностей аппаратуры от верхних, а те, в свою очередь, обеспечивают удобный интерфейс для пользователей.</p>
<p><u>Основные проблемы организации программного обеспечения ввода-вывода</u></p>
<p>1. Независимость от устройств. Эта концепция означает возможность написания программ способных получать доступ к любому устройству ввода-вывода, без предварительного указания конкретного устройства. Вид программы не должен зависеть от того, читает ли она данные с гибкого диска или с жесткого диска.  Все проблемы, связанные с отличиями этих устройств должна решать ОС. Очень близкой к идее независимости от устройств является идея единообразного именования, то есть для именования устройств должны быть приняты единые правила. Имя файла или устройства должно быть просто текстовой строкой или целым числом и никоим образом не зависеть от физического устройства.</p>
<p>2. Обработка ошибок. Вообще говоря, ошибки следует обрабатывать как можно ближе к аппаратуре. Если контроллер обнаруживает ошибку чтения, то он должен попытаться ее скорректировать. Если же это ему не удается, то исправлением ошибок должен заняться драйвер устройства. Многие ошибки могут исчезать при повторных попытках выполнения операций ввода-вывода, например, ошибки, вызванные наличием пылинок на головках чтения или на диске. И только если нижний уровень не может справиться с ошибкой, он сообщает об ошибке верхнему уровню.</p>
<p>3. Способ переноса данных - блокирующий (синхронный) и неблокирующий (асинхронный). Синхронный режим означает, что программный модуль приостанавливает свою работу до тех пор, пока операция ввода-вывода не будет завершена, а при асинхронном режиме программный модуль продолжает выполняться в мультипрограммном режиме одновременно с операцией ввода-вывода. Большинство операций физического ввода-вывода выполняется асинхронно - процессор начинает передачу и переходит на другую работу, пока не наступает прерывание. Пользовательские программы намного легче писать, если операции ввода-вывода блокирующие - после команды READ программа автоматически приостанавливается до тех пор, пока данные не попадут в буфер программы. ОС выполняет операции ввода-вывода асинхронно, но представляет их для пользовательских программ в синхронной форме.</p>
<p>4. Буферизация. Часто данные, поступающие с устройства, не могут быть сохранены сразу там, куда они в конечном итоге направляются. Например, когда пакет приходит по сети, ОС не знает, куда его поместить, пока не будет известно его содержимое, для чего этот пакет нужно где-то временно сохранить. Кроме того, для многих устройств реального времени крайне важными оказываются параметры сроков поступления данных (например для устройств воспроизведения цифрового звука), поэтому полученные данные должны быть помещены в буфер заранее. Таким образом удается избежать неравномерности воспроизведения звука.</p>
<p>5. Одни устройства являются разделяемыми, а другие - выделенными. Диски - это разделяемые устройства, так как одновременный доступ нескольких пользователей к диску не представляет собой проблему. Принтеры - это выделенные устройства, потому что нельзя смешивать строчки, печатаемые различными пользователями. Наличие выделенных устройств создает для операционной системы некоторые проблемы.</p>
<h3 align="center">Многослойная модель подсистемы ввода-вывода</h3>
<ul>Программное обеспечение ввода-вывода делится на четыре слоя (рисунок 1):
	<li>обработка прерываний;</li>
	<li>драйверы устройств;</li>
	<li>независимый от устройств слой операционной системы;</li>
	<li>пользовательский слой программного обеспечения.</li>
</ul>
<p>У каждого уровня есть четко очерченная функция, которую он должен выполнять, и строго определенный интерфейс с соседними уровнями.</p>
<center><%= image_tag("lesson9-1.jpg") %></center>
<p><u>1) Обработка прерываний</u></p>
<p>Прерывания должны быть скрыты как можно глубже в недрах операционной системы, чтобы как можно меньшая часть ОС имела с ними дело. Наилучший способ состоит в разрешении процессу, инициировавшему операцию ввода-вывода, блокировать себя до завершения операции и наступления прерывания. Эффект от прерывания будет состоять в том, что ранее заблокированный процесс теперь продолжит свое выполнение. </p>
<p><u>2) Драйверы устройств</u></p>
<p>Весь зависимый от устройства код помещается в драйвер устройства. Каждый драйвер управляет устройствами одного типа или, может быть, одного класса.</p>
<ul>Под драйвером понимается программный модуль, который:
<li>входит в состав ядра ОС, работая в привилегированном режиме;</li>
<li>непосредственно управляет внешним устройством, взаимодействуя с его контроллером с помощью команд ввода-вывода;</li>
<li>обрабатывает прерывания от контроллера устройства;</li>
<li>предоставляет прикладному программисту удобный интерфейс работы с устройством, экранируя от него низкоуровневые детали управления устройством и организации его данных;</li>
<li>взаимодействие с другими модулями ядра ОС с помощью строго оговоренного интерфейса, описывающего формат передаваемых команд, структуру буферов, способы включения драйвера в состав ОС, способы вызова драйвера и т.п. </li>
</ul>
<p>В операционной системе только драйвер устройства знает о конкретных особенностях какого-либо устройства. Например, только драйвер диска имеет дело с дорожками, секторами, цилиндрами, временем установления головки и другими факторами, обеспечивающими правильную работу диска.
Драйвер устройства принимает запрос от устройств программного слоя и решает, как его выполнить. Типичным запросом является чтение n блоков данных. Если драйвер был свободен во время поступления запроса, то он начинает выполнять запрос немедленно. Если же он был занят обслуживанием другого запроса, то вновь поступивший запрос присоединяется к очереди уже имеющихся запросов, и он будет выполнен, когда наступит его очередь.
Первый шаг в реализации запроса ввода-вывода, например, для диска, состоит в преобразовании его из абстрактной формы в конкретную. Для дискового драйвера это означает преобразование номеров блоков в номера цилиндров, головок, секторов, проверку, работает ли мотор, находится ли головка над нужным цилиндром. Короче говоря, он должен решить, какие операции контроллера нужно выполнить и в какой последовательности. 
После передачи команды контроллеру драйвер должен решить, блокировать ли себя до окончания заданной операции или нет. Если операция занимает значительное время, как при печати некоторого блока данных, то драйвер блокируется до тех пор, пока операция не завершится, и обработчик прерывания не разблокирует его. Если команда ввода-вывода выполняется быстро (например, прокрутка экрана), то драйвер ожидает ее завершения без блокирования. Наконец, драйвер возвращает некоторую информацию о состоянии для информирования вызывающей программы о статусе завершения операции.</p>
<p><u>3) Независимый от устройств слой операционной системы</u></p>
<p>Большая часть программного обеспечения ввода-вывода является независимой от устройств. Точная граница между драйверами и независимыми от устройств программами определяется системой, так как некоторые функции, которые могли бы быть реализованы независимым способом, в действительности выполнены в виде драйверов для повышения эффективности или по другим причинам. </p>
<ul>
	<li>единообразный интерфейс для драйверов устройств;</li>
	<li>буферизация; </li>
	<li>уведомление об ошибках; </li>
	<li>распределение и освобождение выделенных устройств;</li>
	<li>обеспечение независимого размера блока. </li>
</ul>
<p>Остановимся на некоторых функциях данного перечня. Верхним слоям программного обеспечения не удобно работать с блоками разной величины, поэтому данный слой обеспечивает единый размер блока, например, за счет объединения нескольких различных блоков в единый логический блок. В связи с этим верхние уровни имеют дело с абстрактными устройствами, которые используют единый размер логического блока независимо от размера физического сектора. </p>
<p>При создании файла или заполнении его новыми данными необходимо выделить ему новые блоки. Для этого ОС должна вести список или битовую карту свободных блоков диска. На основании информации о наличии свободного места на диске может быть разработан алгоритм поиска свободного блока, независимый от устройства и реализуемый программным слоем, находящимся выше слоя драйверов. </p>
<h4 align="center">Пользовательский слой программного обеспечения </h4>
<p>Хотя большая часть программного обеспечения ввода-вывода находится внутри ОС, некоторая его часть содержится в библиотеках, связываемых с пользовательскими программами. Системные вызовы, включающие вызовы ввода-вывода, обычно делаются библиотечными процедурами. Если программа, написанная на языке С, содержит вызов count = write (fd, buffer, nbytes), то библиотечная процедура write будет связана с программой. Набор подобных процедур является частью системы ввода-вывода. В частности, форматирование ввода или вывода выполняется библиотечными процедурами. Примером может служить функция printf языка С, которая принимает строку формата и, возможно, некоторые переменные в качестве входной информации, затем строит строку символов ASCII и делает вызов write для вывода этой строки. Стандартная библиотека ввода-вывода содержит большое число процедур, которые выполняют ввод-вывод и работают как часть пользовательской программы. </p>
<p>Другой категорией программного обеспечения ввода-вывода является подсистема спулинга (spooling). Спулинг - это способ работы с выделенными устройствами в мультипрограммной системе. Рассмотрим типичное устройство, требующее спулинга - строчный принтер. Хотя технически легко позволить каждому пользовательскому процессу открыть специальный файл, связанный с принтером, такой способ опасен из-за того, что пользовательский процесс может монополизировать принтер на произвольное время. Вместо этого создается специальный процесс - монитор, который получает исключительные права на использование этого устройства. Также создается специальный каталог, называемый каталогом спулинга. Для того, чтобы напечатать файл, пользовательский процесс помещает выводимую информацию в этот файл и помещает его в каталог спулинга. Процесс-монитор по очереди распечатывает все файлы, содержащиеся в каталоге спулинга.</p>
</tr>
</td>
</table>
