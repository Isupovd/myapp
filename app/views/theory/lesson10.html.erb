<h1 align="center">Подсистема спулинга</h1>
<table align="center" width="85%" border="0" bgcolor="#2F4F4F">
	<tr>
		<td>
			<p>Подсистема спулинга (spooling). Спулинг - это способ работы с выделенными (не разделяемыми между процессами) устройствами в мультипрограммной системе. Типичное устройство, требующее спулинга - принтер. </p>
			<p>Если просто позволить каждому пользовательскому процессу открыть специальный файл, связанный с принтером, то принтер может быть монополизирован процессом на произвольное время, что недопустимо. Поэтому создается специальный процесс – монитор, получающий исключительные права на использование устройства, и специальный каталог – каталог спулинга. Чтобы напечатать файл, пользовательский процесс помещает его в каталог спулинга. Процесс-монитор по очереди распечатывает все файлы, содержащиеся в каталоге спулинга.</p>
			<p><b>Байт-ориентированные драйверы</b></p>
			<ul><b>Драйвер байт-ориентированного устройства состоит из следующих стандартных функций:</b>
				<li>open — открывает устройство; </li>
				<li>close — закрывает устройство;</li>
				<li>read — читает данные из устройства;</li>
				<li>write — записывает данные в устройство;</li>
				<li>ioctl — управляет вводом-выводом;</li>
				<li>poll — опрашивает устройство для выяснения, не произошло ли некоторое событие;</li>
				<li>mmap, segmap — используются при отображении файла-устройства в виртуальную память.</li>
			</ul>
			<p>Функции чтения и записи данных выполняют обмен заданной последовательности байт из буфера в области пользователя с контроллером символьного устройства.</p>
			<p>Функция управления ioctl обеспечивает интерфейс к драйверу устройства, который выходит за рамки возможностей функций read и write. С помощью функции ioctl обычно устанавливается режим работы устройства, например, задаются параметры СОМ-порта, такие как разрядность символов, количество стоповых бит, режим проверки четности и т. п.</p>
			<p>Функции, используемые для отображения специального файла в виртуальную память, рассматриваются ниже в разделе «Отображаемые в память файлы».</p>
			<p>Если драйвер не поддерживает какую-либо из стандартных функций, то в таблицу bdevsw помещается указатель на специальную функцию nodev ядра. Например, драйвер принтера может не поддерживать функцию read. Функция nodev при вызове просто возвращает код ошибки ENODEV и на этом завершает свою работу. Для тех случаев, когда функция должна обязательно поддерживаться (примерами таких функций являются функции open и cl ose), но она не выполняет ника-• кой полезной работы, в операционной системе имеется функция nul I dev, которая похожа на функцию nodev, но в отличие от нее возвращает значение 0, которое во всех системных вызовах означает успешное завершение.</p>
			<p>Функция записи осуществляет передачу данных из пользовательского буфера процесса, выдавшего запрос на обмен, в системный буфер, организованный в виде очереди байт. Передача байт идет до тех пор, пока системный буфер не заполнится до некоторого, заранее определенного в драйвере уровня. Затем функция записи драйвера приостанавливается, выполнив системную функцию sleep, переводящую процесс, в рамках которого работает функция записи write, в состояние ожидания.</p>
			<p>Если при очередном прерывании оказывается, что очередь байт уменьшилась до определенной нижней границы, то обработчик прерываний активизирует секцию записи драйвера путем обращения к системной функции wakeup для перевода процесса в состояние готовности. Аналогично организована работа драйвера при чтении данных с устройства.</p>
			<h4 align="center"><b></b>Блок-ориентированные драйверы</b></h4>
		<ul><b>Драйвер блок-ориентированного устройства состоит из следующих функций:</b>
			<li>open — выполняет процедуру логического открытия устройства;</li>
			<li>close — выполняет процедуру логического закрытия устройства;</li>
			<li>strategy — читает или записывает блок;</li>
			<li>print — выводит сообщение об ошибке;</li>
			<li>size — возвращает размер раздела, который представляет данное устройство.</li>
		</ul>
		<p>Указатели на эти функции (то есть их адреса) составляют строку в таблице bdevsw, описывающую один драйвер системы. Ядро UNIX вызывает нужную функцию драйвера, передавая ей параметры, необходимые для работы. Например, при вызове функции open ей передается номер устройства (minor), режим открытия (для чтения, для записи, для чтения и записи и т. д.), а также указатель на идентификаторы безопасности процесса, открывающего файл.</p>
		<p>Процедуры обработки прерываний драйвера в таблице bdevsw не указываются, их адреса помещаются в специальную системную структуру — таблицу прерываний. В UNIX все обработчики прерываний, в том числе и обработчики прерываний аппаратных драйверов, состоят из двух процедур, называемых соответственно top_half — верхняя часть обработчика прерываний и bottom_half — нижняя часть обработчика прерываний. Верхняя часть обработчика прерываний соответствует по назначению ISR-процедуре драйвера Windows NT — она вызывается при возникновении аппаратного запроса прерывания от устройства. В обязанности верхней части входит быстрая реакция на событие в устройстве, вызвавшее генерирование сигнала прерывания. При обработке верхних половин все прерывания с более низкими приоритетами блокируются аппаратно, за счет управления контроллером прерываний (или аналогичным по назначению блоком компьютера). Верхняя половина отвечает также за постановку в очередь на выполнение нижней половины обработчика прерываний драйвера, который выполняет менее срочную и более трудоемкую работу.</p>
		<p>Нижние половины драйверов выполняются с низким уровнем приоритета, так что любые запросы прерываний устройств могут прервать их обработку. Нижние половины обработчиков прерываний драйверов UNIX по назначению соответствуют DPC-процедурам драйверов Windows NT. Часто единственной обязанностью верхней половины обработчика прерываний является постановка в очередь нижней половины для последующего выполнения.</p>
		<p>Примером разделения функций между верхней и нижней половинами является обработчик прерываний от таймера. Верхняя часть, вызываемая 100 раз в секунду, наращивает переменную, хранящую количество тактов системных часов с момента последней загрузки системы, а также две переменные, подсчитывающие, сколько тактов прошло с момента последнего вызова нижней половины и сколько из них пришлось на период работы в режиме системы. Затем верхняя половина ставит в очередь диспетчера прерываний нижнюю половину и завершает свою работу. Нижняя половина обработчика прерываний таймера занимается вычислением статистики на основании данных о тактах, собранных верхней половиной. Нижняя половина вычисляет такие статистические показатели, как средняя загрузка системы в пользовательском и системном режимах, обновляет глобальную переменную системного времени, а также уменьшает оставшееся значение кванта времени текущего процесса. Затем нижняя половина просматривает очередь процедур, ожидающих своего вызова по времени, в число которых входит и планировщик процессов.</p>
		<p>Функция стратегии драйвера strategy выполняет чтение и запись блока данных на основании информации в буфере — особой структуре ядра с именем buf, управляющей обменом данных с диском. Функция strategy выполняет обмен только с системной памятью, так как блок-ориентированный драйвер непосредственно не взаимодействует с пользовательским процессом. Между ним и пользовательским процессом всегда работает промежуточный программный слой или слои — либо слой дискового кэша вместе со слоем файловой системы, либо слой байт-ориентированного драйвера диска, с помощью которого пользовательский процесс может открыть специальный файл, соответствующий диску.</p>
		<ul><b>В число наиболее важных элементов структуры buf входят следующие:</b>
			<li>b_flags — набор бит, в котором задаются тип операции (чтение или запись), синхронный или асинхронный режим операции (при записи), признак активности операции с буфером, признак завершения операции, признак ожидания буфера процессом и некоторые другие;</li>
			<li>b_Jorw, b_back — указатели на последующий и предыдущий буферы в списке активных (используемых) буферов;</li>
			<li>av_forw, av_back — указатели на последующий и предыдущий буферы в списке свободных буферов;	</li>
			<li>b_dev — номер драйвера (major) и номер устройства (minor) из индексного дескриптора специального устройства, для которого выполняется операция обмена данными;</li>
			<li>b_bcount — количество байт, которые нужно передать;</li>
			<li>b_addr — адрес буфера памяти, куда нужно записать или откуда нужно прочитать данные;</li>
			<li>b_blkno — номер блока в разделе диска;</li>
			<li>b_bufsize — размер блока (в ранних версиях UNIX использовался только один размер блока — 512 байт, в версиях, основанных на коде System V Release 4, можно работать с блоками разного размера);</li>
			<li>b__iodone — указатель на функцию, которая вызывается по завершении операции ввода-вывода.</li>
		</ul>
		<p>Функция strategy при вызове получает указатель на структуру buf, описывающую требуемую операцию. На рис. 8.4 приведен пример блок-схемы двух функций драйвера диска — стратегии (hd_strategy) и нижней половины обработчика прерываний (hd_bottom). Функция hd_strategy преобразует логический номер блока в номера цилиндра, головки и сектора и помещает эту информацию в заголовок запроса операции для передачи ее контроллеру диска. В заголовок запроса помещается также другая информация, необходимая для работы контроллера, — это операция чтения или записи, адрес системной памяти, куда нужно поместить прочитанную информацию или откуда контроллеру нужно считать записываемые данные. Драйвер ведет две очереди для передачи запросов на выполнение операций чтения и записи контроллеру диска: рабочую очередь, в которой находятся обрабатываемые контроллером запросы, и очередь приостановленных запросов, куда помещаются новые запросы в том случае, если рабочая очередь заполнена, а ее размер зависит от возможностей контроллера по параллельной обработке запросов.</p>
		<p>После помещения нового запроса в одну из очередей функция стратегии разрешает прерывания от данного устройства и завершает свою работу. Всю дальнейшую работу по обслуживанию поставленных в очереди запросов выполняют контроллер и обработчики прерываний. После выполнения запроса, когда данные либо записаны в системную память (чтение), либо переписаны из системной памяти в блок диска (запись), контроллер генерирует сигнал прерывания. По этому сигналу вызывается верхняя часть обработчика прерываний дискового драйвера (на рисунке не показана), которая просто ставит в очередь диспетчера прерываний нижнюю часть обработчика прерываний диска hd_bottom. Эта процедура считывает данные из регистра управления контроллера для того, чтобы определить, корректно ли завершилась запрошенная операция. Если признак ошибки в регистре не установлен, то в рабочую очередь контроллера помещается следующий заголовок запроса из очереди приостановленных запросов, а по завершении операции вызывается функция iodone, указатель на которую имеется в буфере buf операции.</p>
	</tr>
</td>
</table>
