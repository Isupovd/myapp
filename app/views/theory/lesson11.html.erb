<h1 align="center"> Обработка прерываний и текущий процесс </h1>
<table align="center" width="85%" border="0" bgcolor="#2F4F4F">
	<tr>
		<td>
			<p>Во время выполнения программы внутри ЭВМ и во внешней среде могут возникать события, требующие немедленной реакции на них со стороны машины. Реакция состоит в том, что машина прерывает обработку текущей программы и переходит к выполнению некоторой другой программы, специально предназначенной для данного события. По завершении этой программы ЭВМ возвращается к выполнению прерванной программы. Такой процесс называется прерыванием. </p>
			<p>Прерывание – реакция на входной сигнал запроса прерывания или команду прерывания.</p>
			<p>Принципиально важным является то, что моменты возникновения событий, требующих прерывания программ, заранее неизвестны и поэтому не могут быть учтены при программировании.</p>
			<ul><b>Прерывания бывают:</b>
				<li>Внешние (аппаратные) – прерывания могут возникать в результате действий пользователя или в результате поступления сигналов от аппаратных устройств (например, сигналов завершения ввода-вывода от принтера или винчестера). Такие прерывания возникают между выполнением двух команд программы.</li>
				<li>Внутренние – происходят в случае возникновения программной ошибки или сбоя, после которого нельзя продолжить выполнение программы, например, деление на ноль, обращение по несуществующему адресу памяти. Возникают при выполнении команд программы.</li>
				<li>Программные прерывания возникают при выполнении особой команды процессора, имитирующей прерывание. То есть после этой команды происходит переход на новую последовательность команд.</li>
			</ul>
			<p>Прерывание работы МП по запросу внешних устройств устраняет необходимость выполнения МП неэффективных операций по проверке готовности внешних устройств к обмену данными и снижает затраты времени на ожидание готовности периферийного устройства к обмену. Прерывания необходимы при обмене данными с большим числом асинхронно работающих внешних устройств.</p>
			<p>Каждое событие, требующее прерывания, сопровождается сигналом, оповещающим об этом событии ЭВМ, который называется запросом прерывания. Программу, затребованную запросом прерывания, называют прерывающей программой, а программу, выполнявшуюся до появления запроса, - прерываемой программой.</p>
			<p>В сущности, запросы прерывания поступают от нескольких параллельно развивающихся во времени процессов, требующих в произвольные моменты времени обслуживания со стороны процессора. К этим процессам относится выполнение основной программы, контроль правильности работы ЭВМ, операции ввода-вывода и т.п.</p>
			<p>Система прерываний позволяет значительно эффективнее использовать процессор при наличии нескольких протекающих параллельно во времени процессов.</p>
			<p>Для эффективной реализации системы прерываний ЭВМ снабжается соответствующими аппаратными и программными средствами, совокупность которых называется контроллером прерываний.</p>
			<h4><b>Порядок обработки прерывания</b></h4>
			<ul><b>Основными функциями системы прерываний являются:</b>
				<li>запоминание состояния прерываемой программы;</li>
				<li>осуществление перехода к прерывающей программе;</li>
				<li>восстановление состояния прерванной программы;</li>
				<li>возврат к прерванной программе.</li>
			</ul>
			<p>Обычно прерывание допускается после завершения выполнения текущей команды. В этом случае время реакции определяется в основном временем выполнения одной команды.</p>
			<p>Это время реакции может оказаться недопустимо большим для ЭВМ, работающих в реальном масштабе времени. В таких машинах часто допускается прерывание после любого такта выполнения команды. Однако при этом возрастает количество информации, подлежащей запоминанию и восстановлению при переключении программ, так как в этом случае необходимо сохранять состояния счетчика тактов, регистра кода операции и некоторые другие в момент прерывания.</p>
			<h4><b>Классы (уровни) прерываний</b></h4>
			<p>В ЭВМ число различных запросов прерывания может достигать нескольких сотен. В таких случаях запросы обычно разделяют на отдельные классы или уровни.</p>
			<p>Совокупность запросов, инициирующих одну и ту же прерывающую программу, образует класс или уровень прерывания. Объединение запросов в классы прерывания позволяет уменьшить объем аппаратуры, но связано с замедлением работы системы прерывания. </p>
			<p><b>Вектор прерывания</b></p>
			<p>Вектором прерывания называют электрический сигнал, посылаемый на шины процессора. По вектору прерывания можно определить всю необходимую информацию для перехода к прерывающей программе, в том числе ее начальный адрес. Каждому уровню прерывания соответствует свой вектор прерывания. Векторы прерывания обычно находятся в специально выделенных фиксированных ячейках памяти.</p>
			<p>Процедура организации перехода к прерывающей программе выделяет из всех выставленных запросов тот, который имеет наибольший приоритет, выполняет передачу текущего состояния прерываемой программы из регистров процессора в стек, загружает в регистры процессора вектор прерывания и передает управление прерывающей программе.</p>
			<p><b>Организация вложенных прерываний</b></p>
			<p>Возможна ситуация, когда в момент обработки первого прерывания приходит запрос на еще одно прерывание.</p>
			<p>При наличии нескольких источников запросов прерываний должен быть установлен определенный порядок в обслуживании поступающих запросов.</p>
			<p>В системе установлены приоритетные соотношения между запросами прерываний.</p>
			<p>Приоритетные соотношения определяют, какой из нескольких поступивших запросов подлежит обработке в первую очередь, и устанавливают, имеет или не имеет право данный запрос прерывать ту или иную программу.</p>
			<p>Например, запрос на прерывание от таймера всегда приоритетнее запроса от любого внешнего устройства, а программы пользователя имеют самый низкий приоритет и могут быть прерваны чем угодно.</p>
			<p>Существует понятие глубины прерывания - это максимальное число программ, которые могут прерывать друг друга. Если после перехода к прерывающей программе и вплоть до ее окончания прием других запросов запрещается, то говорят, что система имеет глубину прерывания, равную 1. Глубина равна n, если допускается последовательное прерывание до n программ. Системы с большим значением глубины прерывания обеспечивают более быструю реакцию на срочные запросы.</p>
			<p>Различают использование абсолютных и относительных приоритетов.</p>
			<p><b>Схема с абсолютными приоритетами:</b></p>
			<p>Поступивший запрос с более высоким приоритетом, чем обрабатывающийся сейчас, прерывает выполняемую программу. </p>
			<p><b>Схема с относительными приоритетами:</b></p>
			<p>Поступивший запрос является первым кандидатом на обслуживание после завершения выполнения текущей программы. Даже если его приоритет выше, все равно выполняющаяся программа должна завершиться.</p>
			<p>Если наиболее приоритетный из выставленных запросов прерывания не превосходит по уровню приоритета выполняемую процессором программу, то запрос прерывания игнорируется или его обслуживание откладывается до завершения выполнения текущей программы</p>
			<p>Процесс (задача) – программа, находящаяся в режиме выполнения. С каждый процессом связывается его адресное пространство, из которого он может читать и в которое он может писать данные. </p>
			<ul><b>Адресное пространство содержит:</b>
				<li>саму программу;</li>
				<li>данные к программе;</li>
				<li>стек программы.</li>
			</ul>

			<ul>С каждым процессом связывается набор регистров, например:
				<li>счетчик команд (в процессоре) – регистр, в котором содержится адрес следующей стоящей в очереди на выполнение команды. После того, как команда выбрана из памяти, счетчик команд корректируется и указатель переходит к следующей команде.</li>
				<li>указатель стека и другие.</li>
			</ul>
			<p><b>Модель процесса</b></p>
			<p>В многозадачной системе реальный процессор переключается с процесса на процесс, но для упрощения модели рассматривается набор процессов, идущих параллельно (псевдопараллельно). Рассмотрим схему с четырьмя работающими программами.</p>
			<p><b>Создание процесса</b></p>
			<ul><b>Четыре основных события, приводящие к созданию процессов:</b>
				<li>инициализация системы;</li>
				<li>выполнение изданного работающим процессом системного запроса на создание процесса;</li>
				<li>запрос пользователя на создание процесса;</li>
				<li>инициирование пакетного задания.</li>
			</ul>
			<p>С технической точки зрения во всех случаях новый процесс формируется одинаково: текущий процесс выполняет системный запрос на создание нового процесса. В UNIX существует только один системный вызов, направленный на создание нового процесса: fork (ветвление или вилка). Этот запрос создает дубликат вызываемого процесса. В Windows вызов функции CreateProcess интерфейса Win32 управляет и созданием процесса, и запуском в нем нужной программы. После создания нового процесса родительский и дочерний процессы имеют собственные различные адресные пространства.</p>
			<p><b>Завершение процесса</b></p>
			<ul><b>События, приводящие к завершению процесса:</b>
				<li>обычный выход (преднамеренно);</li>
				<li>выход по ошибке (преднамеренно);</li>
				<li>выход по неисправимой ошибке (непреднамеренно);</li>
				<li>уничтожение другим процессом (непреднамеренно).</li>
			</ul>
			<p>В основном процессы завершаются по мере выполнения своей работы.</p>
			<p>1) В Unix системный вызов exit, в Windows – ExitProcess.</p>
			<p>2) Неустранимая ошибка.</p>
			<p>3) Ошибка, вызванная самим процессом, чаще всего связанная с ошибкой в программе. Пример: выполнение недопустимой команды, обращение к несуществующей области памяти, деление на ноль.</p>
			<p>4) Выполнение другим процессом системного запроса на уничтожение процесса. В Unix – kill, в Win32 – TerminateProcess.</p>
			<h4><b>Иерархия процессов</b></h4>
			<p>В некоторых системах родительский и дочерний процессы остаются связанными между собой определенным образом. Дочерний процесс может, в свою очередь, создавать процессы, формируя иерархию процессов.</p>
			<p>В UNIX системах заложена жесткая иерархия процессов. Каждый новый процесс, созданный системным вызовом fork, является дочерним к предыдущему процессу. Дочернему процессу достаются от родительского переменные, регистры и т.п. После вызова fork, как только родительские данные скопированы, последующие изменения в одном из процессов не влияют на другой, но процессы помнят о том, кто является родительским.</p>
			<p>В таком случае, в UNIX существует и прародитель всех процессов - процесс init.</p>
			<p>В Windows не существует понятия иерархии процессов, и все процессы равноправны. Хотя можно задать специальный маркер родительскому процессу, позволяющий контролировать дочерний процесс.</p>
			<h4><b>Состояния процессов</b></h4>
			<ul><b>Три возможных состояния процесса:</b>
				<li>выполнение (в этот конкретный момент использующий процессор);</li>
				<li>готовность (процесс временно приостановлен, чтобы позволить выполняться другому процессу);</li>
				<li>ожидание (процесс не может быть запущен прежде, чем произойдет некое внешнее событие).</li>
			</ul>
			<h4><b>Реализация процессов</b></h4>
			<p>Для реализации модели процессов ОС содержит таблицу (массив структур), называемую таблицей процессов, с одним элементом для каждого процесса (блоком управления процессом). Элементы таблицы содержат информацию о состоянии процесса, счетчике команд, указателе стека, распределении памяти, а также всю остальную информацию, которую необходимо сохранять при переключении в состояние готовности или блокировки для последующего запуска.</p>



